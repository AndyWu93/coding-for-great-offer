package class10;

/**
 * 给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数
 * 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对，否则不是
 * 由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值
 * 1 <= n <= 1000
 * 0 <= k <= 1000
 *
 * 题意： 数字1~n，产生k个逆序对的排列有几个
 * 解题：
 * 	本题看数据量，明显是O(n*k)的解法，O(n*k)常用在样本对应模型
 * 	所以
 * 	dp[i][j]:数字1~i，产生j个逆序对的排列有几个
 * 先把首行首列求出来
 * 	dp[0][0]=1 : 没有数,也不需要逆序对，1种排列
 * 	dp[0][j]=0 : 没有数,但需要逆序对，没办法
 * 	dp[i][0]=1 : 有数，不能产生逆序对的排列，只能是从小到大的顺序排列
 * 普遍位置
 * 	本题普遍位置有点难，遇到这种情况，举例子分析就好了
 * 	比如
 * 	dp[5][3]
 * 	一般样本对应都是观察最后一个样本，所以这里观察5，放在不同位置，有什么反应，1~4用abcd代替，表示可能是任意排列
 * 	1. 放在最后：abcd5，没有产生新的逆序对，所以需要abcd产生3个逆序对的个数即dp[4][3]
 * 	2. 放在倒数第二个：abc5d，产生1个新的逆序对，所以需要abcd产生2个逆序对的个数即dp[4][2]
 * 	...
 * 	dp[5][3] = sum(dp[4][3..0])
 * 仅仅这样，过不了，因为有枚举行为，观察下一列看看
 * 	dp[5][3] = sum(dp[4][3..0])
 * 	dp[5][4] = sum(dp[4][4..0])
 * 所以dp[i][j] = dp[i-1][j] + dp[i][j-1]
 * 这样就行了吗？继续分析一下dp[5][5]:
 * 	1. 放在最后：abcd5，没有产生新的逆序对，所以需要abcd产生5个逆序对的个数即dp[4][5]
 *  2. 放在倒数第二个：abc5d，产生1个新的逆序对，所以需要abcd产生4个逆序对的个数即dp[4][4]
 *  ...
 * 	n. 放在最前：5abcd，产生4个新的逆序对，所以需要abcd产生1个逆序对的个数即dp[4][1]
 * 	dp[5][5] = sum(dp[4][5..1])
 * 观察枚举
 *  dp[5][5] = sum(dp[4][5..1])
 * 	dp[5][6] = sum(dp[4][6..2])
 * 	dp[5][7] = sum(dp[4][7..3])
 * 所以当j>=i时：dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]
 */
// 测试链接 : https://leetcode.com/problems/k-inverse-pairs-array/
public class Code03_KInversePairs {

	/**
	 * mod版
	 */
	public static int kInversePairs(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		/*规模：0~n个数，产生0~k个逆序对*/
		int[][] dp = new int[n + 1][k + 1];
		dp[0][0] = 1;
//		dp[0][1..K] = 0;默认就是0
		int mod = 1000000007;
		for (int i = 1; i <= n; i++) {
			/*有数，不要逆序对*/
			dp[i][0] = 1;
			for (int j = 1; j <= k; j++) {
				/*
				* 题目中要求最后的值需要mod，所以dp表中所有的值都是mod值
				* 两个格子相加，不影响mod值
				* 两个格子相减，可能会变成负数，所以相减后的值需要加一个mod，保证成为正数后再mod
				* */
				dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;
				if (j >= i) {
					dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
				}
			}
		}
		return dp[n][k];
	}

	/**
	 * 无mod版
	 */
	public static int kInversePairs2(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		int[][] dp = new int[n + 1][k + 1];
		dp[0][0] = 1;
		for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
			for (int j = 1; j <= k; j++) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
				if (j >= i) {
					dp[i][j] -= dp[i - 1][j - i];
				}
			}
		}
		return dp[n][k];
	}

}
